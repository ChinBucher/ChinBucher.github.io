---
layout: post
title:  "三次握手&四次挥手"
date:   2020-09-10 19:50:00
categories: 运维
---

#### 三次握手和四次挥手过程   

### 三次握手：客户端来确认互相的收发能力  
>1、第一次握手：客户端给服务器发送一个 SYN 报文  
>=>客户端的发送能力、服务端的接收能力是正常的  
>2、第二次握手：服务器收到 SYN 报文之后，会应答一个 SYN+ACK 报文  
>=>服务端的接收、发送能力，客户端的接收、发送能力是正常的  
>3、第三次握手：客户端收到 SYN+ACK 报文之后，会回应一个 ACK 报文  
>=>客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常  
>4、服务器收到 ACK 报文之后，三次握手建立完成  
![avatar](/assets/images/study/http01.png)

#### 半连接队列  
服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。  
#### 全连接队列  
就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象  
**第三次握手的时候，是可以携带数据的。

### 四次挥手：客户端与服务端 分别 确认自己的收发能力  
>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。
>即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。    
>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。  
>即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。  
>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。
>即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。  
>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。
>即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。

因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，"你发的FIN报文我收到了"。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。
![avatar](/assets/images/study/http02.png)


>参考：  
>[面试官，不要再问我三次握手和四次挥手]: 


[面试官，不要再问我三次握手和四次挥手]:  https://juejin.im/post/6844903958624878606